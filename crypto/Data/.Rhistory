c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 120 # The price you expect the stock to hit
symbols <- "ARKK" # The symbol you want
Expiration <- "2021-06-11" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-06-04" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
library(quantmod)
library(alphavantager)
library(lubridate)
library(forecast)
library(zoo)
library(data.table)
#library(AlpacaforR)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
symbols <- "SPY"
#Stock <- getSymbols(symbols, src = "av", output.size = "full", periodicity = "daily", auto.assign = FALSE)
dateMarch6 <- as.Date("2020-01-01")
#Stock <- Stock[index(Stock) >= dateMarch6,]
#SPY <- getSymbols("SPY", from = dateMarch6, auto.assign = FALSE)
#SPY <- av_get(symbols, "TIME_SERIES_DAILY_ADJUSTED", outputsize = "full")
SPY <- getSymbols("SPY", from=Sys.Date()-(365), to = Sys.Date()+1, verbose = FALSE, auto.assign = FALSE)
#SPY <- SPY[SPY$timestamp >= dateMarch6,]
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "60min", outputsize = "full")
par(mfrow=c(2,1))
SPY$Returns <- SPY$SPY.Adjusted / shift(SPY$SPY.Adjusted) - 1
SPY <- na.omit(SPY)
SPY$col <- as.factor(ifelse(SPY$Returns > 0,1,0))
SPY <- as.data.frame(SPY)
barplot(SPY$Returns, col = c("red","green")[SPY$col], main = "SPY Daily Moves", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
#box()
avgRet <- function(x){
return(prod(x + 1))
}
SPY$RollMean <- c(rep(NA,2),rollapply(SPY$Returns, width = 3, FUN = avgRet))
SPY$colRoll <- as.factor(ifelse(SPY$RollMean - 1 > 0, 1, 0))
barplot(SPY$RollMean - 1, col = c("red","green")[SPY$colRoll], main = "SPY/3 day rolling average", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
# model1 <- auto.arima(SPY$RollMean-1)
# model2 <- auto.arima(SPY$Returns, max.p = 10, max.d = 5, max.D = 5, max.q = 10)
# prediction <- c((SPY$RollMean - 1),predict(model1, n.ahead = 5)$pred)
# #prediction <- c((SPY$Returns),predict(model2, n.ahead = 5)$pred)
# barplot(prediction)
#
# #Returns <- data.frame(index(Stock)[-1],(diff(Stock$DIA.Close)) / Stock$DIA.Close[-1])
# colnames(Returns) <- c("timestamp","Close")
# barplot(Returns$Close)
# plot(Returns$Close,type = 'l')
#
# mean(Returns$Close, na.rm = TRUE)
# sd(Returns$Close)
# confiINT <- c(quantile(Returns$Close, .1), quantile(Returns$Close,.9))
# # confiINT <- mean(Returns$Close) + c(1.5 * sd(Returns$Close), -1.5 * sd(Returns$Close))
# confiINT
# positiveRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close > 0 , Returns$Close,0))
# negativeRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close < 0 , Returns$Close , 0))
# #Returns$Adjusted.Close <- ifelse(Returns$Adjusted.Close > 0,Returns$Adjusted.Close,0)
# #positiveRet$Close > 0
# onlyPositive <- Returns$Close > 0
# PositiveGains <- Returns[onlyPositive,]
# dateDiff <- diff(PositiveGains$timestamp)
# dateDiff
# PositiveGains
# PositiveGains$Close
# PositiveGains$dateDiff <- c(0,dateDiff)
# plusMinus1D <- sort(unique(c(which(PositiveGains$Close > .02) - 1,which(PositiveGains$Close > .02),which(PositiveGains$Close > .02) +1)),decreasing = FALSE)
#
# #plusMinus1D <- sort(c(which(PositiveGains$dateDiff == 1) -1, which(PositiveGains$dateDiff == 1), which(PositiveGains$dateDiff == 1) + 1), decreasing = FALSE)
# PositiveGains[plusMinus1D,]
#
# culreturn <- function(x){
#   return(prod(x + 1))
# }
# rollAVG <- c(numeric(5),rollapply(Returns$Adjusted.Close,6,culreturn))
# Returns$rollAvg5 <- rollAVG
# plot(Returns$timestamp[-(1:5)],Returns$rollAvg5[-(1:5)],type = 'l')
# plot(Returns$timestamp,Returns$Adjusted.Close, type = 'l')
# plot(Stock$timestamp[1500:1800],Stock$adjusted_close[1500:1800], type = 'l')
library(quantmod)
library(alphavantager)
library(lubridate)
library(forecast)
library(zoo)
library(data.table)
#library(AlpacaforR)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
symbols <- "QQQ"
#Stock <- getSymbols(symbols, src = "av", output.size = "full", periodicity = "daily", auto.assign = FALSE)
dateMarch6 <- as.Date("2020-01-01")
#Stock <- Stock[index(Stock) >= dateMarch6,]
#QQQ <- getSymbols("QQQ", from = dateMarch6, auto.assign = FALSE)
#QQQ <- av_get(symbols, "TIME_SERIES_DAILY_ADJUSTED", outputsize = "full")
QQQ <- getSymbols("QQQ", from=Sys.Date()-(365*2), to = Sys.Date()+1, verbose = FALSE, auto.assign = FALSE)
#QQQ <- QQQ[QQQ$timestamp >= dateMarch6,]
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "60min", outputsize = "full")
par(mfrow=c(2,1))
QQQ$Returns <- QQQ$QQQ.Adjusted / shift(QQQ$QQQ.Adjusted) - 1
QQQ <- na.omit(QQQ)
QQQ$col <- as.factor(ifelse(QQQ$Returns > 0,1,0))
QQQ <- as.data.frame(QQQ)
barplot(QQQ$Returns, col = c("red","green")[QQQ$col], main = "QQQ Daily Moves", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
#box()
avgRet <- function(x){
return(prod(x + 1))
}
QQQ$RollMean <- c(rep(NA,2),rollapply(QQQ$Returns, width = 3, FUN = avgRet))
QQQ$colRoll <- as.factor(ifelse(QQQ$RollMean - 1 > 0, 1, 0))
barplot(QQQ$RollMean - 1, col = c("red","green")[QQQ$colRoll], main = "QQQ/3 day rolling average", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
# model1 <- auto.arima(QQQ$RollMean-1)
# model2 <- auto.arima(QQQ$Returns, max.p = 10, max.d = 5, max.D = 5, max.q = 10)
# prediction <- c((QQQ$RollMean - 1),predict(model1, n.ahead = 5)$pred)
# #prediction <- c((QQQ$Returns),predict(model2, n.ahead = 5)$pred)
# barplot(prediction)
#
# #Returns <- data.frame(index(Stock)[-1],(diff(Stock$DIA.Close)) / Stock$DIA.Close[-1])
# colnames(Returns) <- c("timestamp","Close")
# barplot(Returns$Close)
# plot(Returns$Close,type = 'l')
#
# mean(Returns$Close, na.rm = TRUE)
# sd(Returns$Close)
# confiINT <- c(quantile(Returns$Close, .1), quantile(Returns$Close,.9))
# # confiINT <- mean(Returns$Close) + c(1.5 * sd(Returns$Close), -1.5 * sd(Returns$Close))
# confiINT
# positiveRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close > 0 , Returns$Close,0))
# negativeRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close < 0 , Returns$Close , 0))
# #Returns$Adjusted.Close <- ifelse(Returns$Adjusted.Close > 0,Returns$Adjusted.Close,0)
# #positiveRet$Close > 0
# onlyPositive <- Returns$Close > 0
# PositiveGains <- Returns[onlyPositive,]
# dateDiff <- diff(PositiveGains$timestamp)
# dateDiff
# PositiveGains
# PositiveGains$Close
# PositiveGains$dateDiff <- c(0,dateDiff)
# plusMinus1D <- sort(unique(c(which(PositiveGains$Close > .02) - 1,which(PositiveGains$Close > .02),which(PositiveGains$Close > .02) +1)),decreasing = FALSE)
#
# #plusMinus1D <- sort(c(which(PositiveGains$dateDiff == 1) -1, which(PositiveGains$dateDiff == 1), which(PositiveGains$dateDiff == 1) + 1), decreasing = FALSE)
# PositiveGains[plusMinus1D,]
#
# culreturn <- function(x){
#   return(prod(x + 1))
# }
# rollAVG <- c(numeric(5),rollapply(Returns$Adjusted.Close,6,culreturn))
# Returns$rollAvg5 <- rollAVG
# plot(Returns$timestamp[-(1:5)],Returns$rollAvg5[-(1:5)],type = 'l')
# plot(Returns$timestamp,Returns$Adjusted.Close, type = 'l')
# plot(Stock$timestamp[1500:1800],Stock$adjusted_close[1500:1800], type = 'l')
library(quantmod)
library(alphavantager)
library(lubridate)
library(forecast)
library(zoo)
library(data.table)
#library(AlpacaforR)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
symbols <- "SPY"
#Stock <- getSymbols(symbols, src = "av", output.size = "full", periodicity = "daily", auto.assign = FALSE)
dateMarch6 <- as.Date("2020-01-01")
#Stock <- Stock[index(Stock) >= dateMarch6,]
#SPY <- getSymbols("SPY", from = dateMarch6, auto.assign = FALSE)
#SPY <- av_get(symbols, "TIME_SERIES_DAILY_ADJUSTED", outputsize = "full")
SPY <- getSymbols("SPY", from=Sys.Date()-(365), to = Sys.Date()+1, verbose = FALSE, auto.assign = FALSE)
#SPY <- SPY[SPY$timestamp >= dateMarch6,]
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "60min", outputsize = "full")
par(mfrow=c(2,1))
SPY$Returns <- SPY$SPY.Adjusted / shift(SPY$SPY.Adjusted) - 1
SPY <- na.omit(SPY)
SPY$col <- as.factor(ifelse(SPY$Returns > 0,1,0))
SPY <- as.data.frame(SPY)
barplot(SPY$Returns, col = c("red","green")[SPY$col], main = "SPY Daily Moves", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
#box()
avgRet <- function(x){
return(prod(x + 1))
}
SPY$RollMean <- c(rep(NA,2),rollapply(SPY$Returns, width = 3, FUN = avgRet))
SPY$colRoll <- as.factor(ifelse(SPY$RollMean - 1 > 0, 1, 0))
barplot(SPY$RollMean - 1, col = c("red","green")[SPY$colRoll], main = "SPY/3 day rolling average", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
# model1 <- auto.arima(SPY$RollMean-1)
# model2 <- auto.arima(SPY$Returns, max.p = 10, max.d = 5, max.D = 5, max.q = 10)
# prediction <- c((SPY$RollMean - 1),predict(model1, n.ahead = 5)$pred)
# #prediction <- c((SPY$Returns),predict(model2, n.ahead = 5)$pred)
# barplot(prediction)
#
# #Returns <- data.frame(index(Stock)[-1],(diff(Stock$DIA.Close)) / Stock$DIA.Close[-1])
# colnames(Returns) <- c("timestamp","Close")
# barplot(Returns$Close)
# plot(Returns$Close,type = 'l')
#
# mean(Returns$Close, na.rm = TRUE)
# sd(Returns$Close)
# confiINT <- c(quantile(Returns$Close, .1), quantile(Returns$Close,.9))
# # confiINT <- mean(Returns$Close) + c(1.5 * sd(Returns$Close), -1.5 * sd(Returns$Close))
# confiINT
# positiveRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close > 0 , Returns$Close,0))
# negativeRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close < 0 , Returns$Close , 0))
# #Returns$Adjusted.Close <- ifelse(Returns$Adjusted.Close > 0,Returns$Adjusted.Close,0)
# #positiveRet$Close > 0
# onlyPositive <- Returns$Close > 0
# PositiveGains <- Returns[onlyPositive,]
# dateDiff <- diff(PositiveGains$timestamp)
# dateDiff
# PositiveGains
# PositiveGains$Close
# PositiveGains$dateDiff <- c(0,dateDiff)
# plusMinus1D <- sort(unique(c(which(PositiveGains$Close > .02) - 1,which(PositiveGains$Close > .02),which(PositiveGains$Close > .02) +1)),decreasing = FALSE)
#
# #plusMinus1D <- sort(c(which(PositiveGains$dateDiff == 1) -1, which(PositiveGains$dateDiff == 1), which(PositiveGains$dateDiff == 1) + 1), decreasing = FALSE)
# PositiveGains[plusMinus1D,]
#
# culreturn <- function(x){
#   return(prod(x + 1))
# }
# rollAVG <- c(numeric(5),rollapply(Returns$Adjusted.Close,6,culreturn))
# Returns$rollAvg5 <- rollAVG
# plot(Returns$timestamp[-(1:5)],Returns$rollAvg5[-(1:5)],type = 'l')
# plot(Returns$timestamp,Returns$Adjusted.Close, type = 'l')
# plot(Stock$timestamp[1500:1800],Stock$adjusted_close[1500:1800], type = 'l')
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 345 # The price you expect the stock to hit
symbols <- "DIA" # The symbol you want
Expiration <- "2021-07-16" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-07-09" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 345 # The price you expect the stock to hit
symbols <- "DIA" # The symbol you want
Expiration <- "2021-07-16" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-07-09" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 345 # The price you expect the stock to hit
symbols <- "DIA" # The symbol you want
Expiration <- "2021-07-16" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-07-09" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
install.packages("languageserver")
library(quantmod)
getSymbols("BTC-USD")
View(`BTC-USD`)
View(`BTC-USD`)
View(`BTC-USD`)
exp(-qnorm(.99)^2/2)/(sqrt(2*pi)*(.99)
)
exp(-qnorm(.99)^2/2)/(sqrt(2*pi)*(.99))
exp(-qnorm(.99)^2/2)/(sqrt(2*pi)*(.99))*100
exp(-2.33^2/2)/(sqrt(2*pi)*(.99))*100
exp(-2.326^2/2)/(sqrt(2*pi)*(.99))*100
qnorm(.05)
library(quantmod)
# Setting directory and declaring btc as base -----------------------------
setwd("D:/RedX Capital/crypto/Data/master_data")
file_names <-list.files()
file_names <- file_names[file_names != "temp"]
tickers <- read.csv("D:/RedX Capital/crypto/crypto_master.csv")
tickers$TICKER <- tolower(tickers$TICKER)
btc_file <- 'btc-usd-max.csv'
# functions ---------------------------------------------------------------
tic_close_mkt_str <- function(file_name) { # gets the ticker and return {ticker}_close and {ticker}_mktcap
tic <- strsplit(file_name, "-")[[1]][1]
tic_close = paste(tic,"_close", sep="")
tic_mktcap = paste(tic,"_mktcp", sep="")
return(c(tic_close, tic_mktcap))
}
reorganize_df <- function(file_name) { # Reads csv files and organizes the columns
df <- read.csv(file_name)
df$Close <- as.numeric(c(df$price[-1],NA))
df <- df[,c(1,5,3)]
tic_info <- tic_close_mkt_str(file_name)
colnames(df) <- c("Date", tic_info[1], tic_info[2])
df$Date <- as.Date(df$Date)
return(na.omit(df))
}
# functions ---------------------------------------------------------------
master_df <- reorganize_df(btc_file)
ticker_close <- vector()
ticker_mktcap <- vector()
for (i in file_names) {
tic_info <- tic_close_mkt_str(i)
ticker_close <- c(ticker_close, tic_info[1])
ticker_mktcap <- c(ticker_mktcap, tic_info[2])
}
file_names <- file_names[file_names != btc_file]
for (i in file_names) {
df <- reorganize_df(i)
master_df <- merge(x=master_df, y=df, by="Date", all.x=TRUE)
}
master_df$total_mktcp <- rowSums(master_df[,ticker_mktcap], na.rm=TRUE)
ticker_weight <- vector()
for (i in ticker_mktcap) {
tic <- strsplit(i, "_")[[1]][1]
tic_weight <- paste(tic, "_wgt", sep="")
ticker_weight <- c(ticker_weight, tic_weight)
master_df[tic_weight] <- master_df[,i] / master_df$total_mktcp
}
idx_df <- data.frame(Date=master_df[,"Date"])
idx_df$index <- rowSums(master_df[ticker_weight] * master_df[ticker_close], na.rm=TRUE)
idx_df$returns <- as.numeric(quantmod::Lag(idx_df$index)) / idx_df$index - 1
#plot(idx_df$Date, idx_df$index, type='l', xlab="Date", ylab="Price", main="Crpyto Index")
write.csv(idx_df,"D:/RedX Capital/crypto/Data/Crypto_DJ.csv", row.names = FALSE)
plot(idx_df$Date, idx_df$index, type='l', xlab="Date", ylab="Price", main="Crpyto Index")
plot(idx_df$Date, idx_df$returns, type='l', xlab="Date", ylab="Price", main="Crpyto Index")
setwd("D:/RedX Capital/crypto/Data")
crypto_mkt <- read.csv("D:/RedX Capital/crypto/Data/Crypto_DJ.csv")
library(forecast)
model=auto.arima(crypto_mkt$index, max.d = 1, max.D = 0, max.order = 15)
summary(model)
mean(crypto_mkt$returns, na.rm = TRUE)
future=forecast(model, h=10)
model_ret=auto.arima(crypto_mkt$returns, max.order = 10)
forecast_model_ret=forecast(model_ret, h=300)
plot(forecast_model_ret)
model_ret=auto.arima(crypto_mkt$index, max.order = 10)
plot(future)
future=forecast(model, h=150)
plot(future)
model
future=forecast(model, h=365)
plot(future)
future
View(crypto_mkt)
future[(nrow(future)-365):]
future[(nrow(future)-365):,]
future$method[(nrow(future)-365):]
future
tail(future,365)
View(crypto_mkt)
tail(future$lower,365)
23654.79 / 32353.86
23654.79 / 32353.86 -1
16931.40 / 32353.86 -1
View(idx_df)
View(master_df)
master_df[tic_weight]
tic_weight
ticker_weight
master_df[ticker_weight]
master_df[nrow(master_df),ticker_weight]
sort(master_df[nrow(master_df),ticker_weight])
