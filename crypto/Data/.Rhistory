#Stock <- Stock[index(Stock) >= dateMarch6,]
#SPY <- getSymbols("SPY", from = dateMarch6, auto.assign = FALSE)
#SPY <- av_get(symbols, "TIME_SERIES_DAILY_ADJUSTED", outputsize = "full")
SPY <- getSymbols("SPY", from=Sys.Date()-(365), to = Sys.Date()+1, verbose = FALSE, auto.assign = FALSE)
#SPY <- SPY[SPY$timestamp >= dateMarch6,]
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "60min", outputsize = "full")
par(mfrow=c(2,1))
SPY$Returns <- SPY$SPY.Adjusted / shift(SPY$SPY.Adjusted) - 1
SPY <- na.omit(SPY)
SPY$col <- as.factor(ifelse(SPY$Returns > 0,1,0))
SPY <- as.data.frame(SPY)
barplot(SPY$Returns, col = c("red","green")[SPY$col], main = "SPY Daily Moves", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
#box()
avgRet <- function(x){
return(prod(x + 1))
}
SPY$RollMean <- c(rep(NA,2),rollapply(SPY$Returns, width = 3, FUN = avgRet))
SPY$colRoll <- as.factor(ifelse(SPY$RollMean - 1 > 0, 1, 0))
barplot(SPY$RollMean - 1, col = c("red","green")[SPY$colRoll], main = "SPY/3 day rolling average", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
# model1 <- auto.arima(SPY$RollMean-1)
# model2 <- auto.arima(SPY$Returns, max.p = 10, max.d = 5, max.D = 5, max.q = 10)
# prediction <- c((SPY$RollMean - 1),predict(model1, n.ahead = 5)$pred)
# #prediction <- c((SPY$Returns),predict(model2, n.ahead = 5)$pred)
# barplot(prediction)
#
# #Returns <- data.frame(index(Stock)[-1],(diff(Stock$DIA.Close)) / Stock$DIA.Close[-1])
# colnames(Returns) <- c("timestamp","Close")
# barplot(Returns$Close)
# plot(Returns$Close,type = 'l')
#
# mean(Returns$Close, na.rm = TRUE)
# sd(Returns$Close)
# confiINT <- c(quantile(Returns$Close, .1), quantile(Returns$Close,.9))
# # confiINT <- mean(Returns$Close) + c(1.5 * sd(Returns$Close), -1.5 * sd(Returns$Close))
# confiINT
# positiveRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close > 0 , Returns$Close,0))
# negativeRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close < 0 , Returns$Close , 0))
# #Returns$Adjusted.Close <- ifelse(Returns$Adjusted.Close > 0,Returns$Adjusted.Close,0)
# #positiveRet$Close > 0
# onlyPositive <- Returns$Close > 0
# PositiveGains <- Returns[onlyPositive,]
# dateDiff <- diff(PositiveGains$timestamp)
# dateDiff
# PositiveGains
# PositiveGains$Close
# PositiveGains$dateDiff <- c(0,dateDiff)
# plusMinus1D <- sort(unique(c(which(PositiveGains$Close > .02) - 1,which(PositiveGains$Close > .02),which(PositiveGains$Close > .02) +1)),decreasing = FALSE)
#
# #plusMinus1D <- sort(c(which(PositiveGains$dateDiff == 1) -1, which(PositiveGains$dateDiff == 1), which(PositiveGains$dateDiff == 1) + 1), decreasing = FALSE)
# PositiveGains[plusMinus1D,]
#
# culreturn <- function(x){
#   return(prod(x + 1))
# }
# rollAVG <- c(numeric(5),rollapply(Returns$Adjusted.Close,6,culreturn))
# Returns$rollAvg5 <- rollAVG
# plot(Returns$timestamp[-(1:5)],Returns$rollAvg5[-(1:5)],type = 'l')
# plot(Returns$timestamp,Returns$Adjusted.Close, type = 'l')
# plot(Stock$timestamp[1500:1800],Stock$adjusted_close[1500:1800], type = 'l')
library(quantmod)
library(alphavantager)
library(lubridate)
library(forecast)
library(zoo)
library(data.table)
#library(AlpacaforR)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
symbols <- "QQQ"
#Stock <- getSymbols(symbols, src = "av", output.size = "full", periodicity = "daily", auto.assign = FALSE)
dateMarch6 <- as.Date("2020-01-01")
#Stock <- Stock[index(Stock) >= dateMarch6,]
#QQQ <- getSymbols("QQQ", from = dateMarch6, auto.assign = FALSE)
#QQQ <- av_get(symbols, "TIME_SERIES_DAILY_ADJUSTED", outputsize = "full")
QQQ <- getSymbols("QQQ", from=Sys.Date()-(365*2), to = Sys.Date()+1, verbose = FALSE, auto.assign = FALSE)
#QQQ <- QQQ[QQQ$timestamp >= dateMarch6,]
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "60min", outputsize = "full")
par(mfrow=c(2,1))
QQQ$Returns <- QQQ$QQQ.Adjusted / shift(QQQ$QQQ.Adjusted) - 1
QQQ <- na.omit(QQQ)
QQQ$col <- as.factor(ifelse(QQQ$Returns > 0,1,0))
QQQ <- as.data.frame(QQQ)
barplot(QQQ$Returns, col = c("red","green")[QQQ$col], main = "QQQ Daily Moves", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
#box()
avgRet <- function(x){
return(prod(x + 1))
}
QQQ$RollMean <- c(rep(NA,2),rollapply(QQQ$Returns, width = 3, FUN = avgRet))
QQQ$colRoll <- as.factor(ifelse(QQQ$RollMean - 1 > 0, 1, 0))
barplot(QQQ$RollMean - 1, col = c("red","green")[QQQ$colRoll], main = "QQQ/3 day rolling average", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
# model1 <- auto.arima(QQQ$RollMean-1)
# model2 <- auto.arima(QQQ$Returns, max.p = 10, max.d = 5, max.D = 5, max.q = 10)
# prediction <- c((QQQ$RollMean - 1),predict(model1, n.ahead = 5)$pred)
# #prediction <- c((QQQ$Returns),predict(model2, n.ahead = 5)$pred)
# barplot(prediction)
#
# #Returns <- data.frame(index(Stock)[-1],(diff(Stock$DIA.Close)) / Stock$DIA.Close[-1])
# colnames(Returns) <- c("timestamp","Close")
# barplot(Returns$Close)
# plot(Returns$Close,type = 'l')
#
# mean(Returns$Close, na.rm = TRUE)
# sd(Returns$Close)
# confiINT <- c(quantile(Returns$Close, .1), quantile(Returns$Close,.9))
# # confiINT <- mean(Returns$Close) + c(1.5 * sd(Returns$Close), -1.5 * sd(Returns$Close))
# confiINT
# positiveRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close > 0 , Returns$Close,0))
# negativeRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close < 0 , Returns$Close , 0))
# #Returns$Adjusted.Close <- ifelse(Returns$Adjusted.Close > 0,Returns$Adjusted.Close,0)
# #positiveRet$Close > 0
# onlyPositive <- Returns$Close > 0
# PositiveGains <- Returns[onlyPositive,]
# dateDiff <- diff(PositiveGains$timestamp)
# dateDiff
# PositiveGains
# PositiveGains$Close
# PositiveGains$dateDiff <- c(0,dateDiff)
# plusMinus1D <- sort(unique(c(which(PositiveGains$Close > .02) - 1,which(PositiveGains$Close > .02),which(PositiveGains$Close > .02) +1)),decreasing = FALSE)
#
# #plusMinus1D <- sort(c(which(PositiveGains$dateDiff == 1) -1, which(PositiveGains$dateDiff == 1), which(PositiveGains$dateDiff == 1) + 1), decreasing = FALSE)
# PositiveGains[plusMinus1D,]
#
# culreturn <- function(x){
#   return(prod(x + 1))
# }
# rollAVG <- c(numeric(5),rollapply(Returns$Adjusted.Close,6,culreturn))
# Returns$rollAvg5 <- rollAVG
# plot(Returns$timestamp[-(1:5)],Returns$rollAvg5[-(1:5)],type = 'l')
# plot(Returns$timestamp,Returns$Adjusted.Close, type = 'l')
# plot(Stock$timestamp[1500:1800],Stock$adjusted_close[1500:1800], type = 'l')
library(quantmod)
library(alphavantager)
library(lubridate)
library(forecast)
library(zoo)
library(data.table)
#library(AlpacaforR)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
symbols <- "SPY"
#Stock <- getSymbols(symbols, src = "av", output.size = "full", periodicity = "daily", auto.assign = FALSE)
dateMarch6 <- as.Date("2020-01-01")
#Stock <- Stock[index(Stock) >= dateMarch6,]
#SPY <- getSymbols("SPY", from = dateMarch6, auto.assign = FALSE)
#SPY <- av_get(symbols, "TIME_SERIES_DAILY_ADJUSTED", outputsize = "full")
SPY <- getSymbols("SPY", from=Sys.Date()-(365), to = Sys.Date()+1, verbose = FALSE, auto.assign = FALSE)
#SPY <- SPY[SPY$timestamp >= dateMarch6,]
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "60min", outputsize = "full")
par(mfrow=c(2,1))
SPY$Returns <- SPY$SPY.Adjusted / shift(SPY$SPY.Adjusted) - 1
SPY <- na.omit(SPY)
SPY$col <- as.factor(ifelse(SPY$Returns > 0,1,0))
SPY <- as.data.frame(SPY)
barplot(SPY$Returns, col = c("red","green")[SPY$col], main = "SPY Daily Moves", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
#box()
avgRet <- function(x){
return(prod(x + 1))
}
SPY$RollMean <- c(rep(NA,2),rollapply(SPY$Returns, width = 3, FUN = avgRet))
SPY$colRoll <- as.factor(ifelse(SPY$RollMean - 1 > 0, 1, 0))
barplot(SPY$RollMean - 1, col = c("red","green")[SPY$colRoll], main = "SPY/3 day rolling average", space = 0, axes = FALSE, ylab = "Returns")
axis(side = 2, pos = 0, at = seq(-.2,.15,.01))
abline(h = seq(-.2,.15,.01))
# model1 <- auto.arima(SPY$RollMean-1)
# model2 <- auto.arima(SPY$Returns, max.p = 10, max.d = 5, max.D = 5, max.q = 10)
# prediction <- c((SPY$RollMean - 1),predict(model1, n.ahead = 5)$pred)
# #prediction <- c((SPY$Returns),predict(model2, n.ahead = 5)$pred)
# barplot(prediction)
#
# #Returns <- data.frame(index(Stock)[-1],(diff(Stock$DIA.Close)) / Stock$DIA.Close[-1])
# colnames(Returns) <- c("timestamp","Close")
# barplot(Returns$Close)
# plot(Returns$Close,type = 'l')
#
# mean(Returns$Close, na.rm = TRUE)
# sd(Returns$Close)
# confiINT <- c(quantile(Returns$Close, .1), quantile(Returns$Close,.9))
# # confiINT <- mean(Returns$Close) + c(1.5 * sd(Returns$Close), -1.5 * sd(Returns$Close))
# confiINT
# positiveRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close > 0 , Returns$Close,0))
# negativeRet <- data.frame(time = Returns$timestamp,Close = ifelse(Returns$Close < 0 , Returns$Close , 0))
# #Returns$Adjusted.Close <- ifelse(Returns$Adjusted.Close > 0,Returns$Adjusted.Close,0)
# #positiveRet$Close > 0
# onlyPositive <- Returns$Close > 0
# PositiveGains <- Returns[onlyPositive,]
# dateDiff <- diff(PositiveGains$timestamp)
# dateDiff
# PositiveGains
# PositiveGains$Close
# PositiveGains$dateDiff <- c(0,dateDiff)
# plusMinus1D <- sort(unique(c(which(PositiveGains$Close > .02) - 1,which(PositiveGains$Close > .02),which(PositiveGains$Close > .02) +1)),decreasing = FALSE)
#
# #plusMinus1D <- sort(c(which(PositiveGains$dateDiff == 1) -1, which(PositiveGains$dateDiff == 1), which(PositiveGains$dateDiff == 1) + 1), decreasing = FALSE)
# PositiveGains[plusMinus1D,]
#
# culreturn <- function(x){
#   return(prod(x + 1))
# }
# rollAVG <- c(numeric(5),rollapply(Returns$Adjusted.Close,6,culreturn))
# Returns$rollAvg5 <- rollAVG
# plot(Returns$timestamp[-(1:5)],Returns$rollAvg5[-(1:5)],type = 'l')
# plot(Returns$timestamp,Returns$Adjusted.Close, type = 'l')
# plot(Stock$timestamp[1500:1800],Stock$adjusted_close[1500:1800], type = 'l')
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 345 # The price you expect the stock to hit
symbols <- "DIA" # The symbol you want
Expiration <- "2021-07-16" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-07-09" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 345 # The price you expect the stock to hit
symbols <- "DIA" # The symbol you want
Expiration <- "2021-07-16" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-07-09" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
# Author: Redmond Xia
# Basic Optimization for option profits
#
#
#
library(quantmod)
library(alphavantager)
library(lubridate)
av_api_key("TCQT2QFAN6SOOT8I")
setDefaults(getSymbols.av, api.key = "TCQT2QFAN6SOOT8I")
# Parameters to change
budget <- 6000 #How much you want to invest
TargetPrc <- 345 # The price you expect the stock to hit
symbols <- "DIA" # The symbol you want
Expiration <- "2021-07-16" # Date you want the option to expire at in format "YYYY-MM-DD"
daysAhead <- "2021-07-09" # How many months you expect to sell the option before expiration from the current date
# . Add that value to today's day to find Option
Stock = getSymbols(Symbols = symbols, from=Sys.Date() - 100, to=Sys.Date() + 1, auto.assign = FALSE)
#Stock <- av_get(symbols, "TIME_SERIES_INTRADAY", interval = "1min", outputsize = "full")
Stock_today <- as.numeric(Stock[(nrow(Stock)),6])
#Stock_today <- Stock[(nrow(Stock)-15),]
#(hour(Stock$timestamp[nrow(Stock)]) == 16)
#plot(Stock$timestamp, Stock$close, type = 'l')
# yahoo finance have option chains info delayed by 15 minutes
Option <- getOptionChain(symbols, Exp = Expiration)
rownames(Option$calls) <- 1:nrow(Option$calls)
Option$calls <- Option$calls[,-c(2,3)]
# How many months you expect to sell the option before expiration. Add that value to today's day to find Option
ATMExpectedSell <- getOptionChain(symbols, Exp = daysAhead)
ATMExpectedSell$calls$MktPrc <- (ifelse(is.na(ATMExpectedSell$calls$Bid),0,ATMExpectedSell$calls$Bid) + ATMExpectedSell$calls$Ask) / 2
# The at the money premium measurement
ATMPremium <- ATMExpectedSell$calls[which.min(abs(ATMExpectedSell$calls$Strike -
Stock_today)),'MktPrc']
Option$calls$MktPrc <- (ifelse(is.na(Option$calls$Bid),0,Option$calls$Bid) + Option$calls$Ask) / 2
Option$calls$ExpSellPrc <- pmax(TargetPrc - Option$calls$Strike,0) + ATMPremium
# This is the amount of options you're able to buy.
Option$calls$NumOption <- floor(budget / (Option$calls$MktPrc * 100)) # each contract is worth 100 shares
Option$calls$Revenue <- (Option$calls$ExpSellPrc * 100) * Option$calls$NumOption
Option$calls$IncrProfit <- c(Option$calls$Revenue[1],diff(Option$calls$Revenue))
# Greater than 0.1 due to machine error
Option$calls$BuySell <- c(NA,ifelse(diff(Option$calls$IncrProfit /
c(Option$calls$IncrProfit[1],diff(Option$calls$Strike))) > 0.1, 1,0))
#Option$calls
View(Option$calls)
Stock_today
install.packages("languageserver")
library(quantmod)
getSymbols("BTC-USD")
View(`BTC-USD`)
View(`BTC-USD`)
View(`BTC-USD`)
exp(-qnorm(.99)^2/2)/(sqrt(2*pi)*(.99)
)
exp(-qnorm(.99)^2/2)/(sqrt(2*pi)*(.99))
exp(-qnorm(.99)^2/2)/(sqrt(2*pi)*(.99))*100
exp(-2.33^2/2)/(sqrt(2*pi)*(.99))*100
exp(-2.326^2/2)/(sqrt(2*pi)*(.99))*100
qnorm(.05)
# This script identify the beta, and provides a regression analysis
library(quantmod)
library(data.table)
# parameters
tickers = c('REML','SPY')
date = Sys.Date() - 365 #"2020-06-09"#
getSymbols(tickers, from=date, to = Sys.Date()+1, verbose = FALSE)
getSymbols('DGS3MO', src='FRED', from=date, to = Sys.Date()+1)
rf = as.numeric(DGS3MO[nrow(DGS3MO),]) / 100
REML_rets = na.omit(REML$REML.Adjusted / shift(REML$REML.Adjusted) - 1)
SPY_rets = na.omit(SPY$SPY.Adjusted / shift(SPY$SPY.Adjusted) - 1)
data = data.frame(REML_rets$REML.Adjusted, SPY_rets$SPY.Adjusted)
data = data[order(data$SPY.Adjusted),]
#data$yhat = predict(polyReg, data)
plot(data$SPY.Adjusted-rf, data$REML.Adjusted-rf,
xlab=paste(tickers[2],' Returns'),
ylab=paste(tickers[1],' Returns'),
main='CAPM Model')
abline(h=0,v=0, col='grey',lty='dashed')
#lines(data$SPY.Adjusted,data$yhat, col='red')
linTrReg <- lm(I(REML.Adjusted-rf)~I(SPY.Adjusted-rf), data = data)
#polyReg <- lm(T.Adjusted~SPY.Adjusted + I(SPY.Adjusted^2) + I(SPY.Adjusted^3), data = data)
#polyReg <- lm(T.Adjusted~exp(-SPY.Adjusted * 16), data = data)
abline(linTrReg, col='red')
points(x=mean(SPY_rets$SPY.Adjusted), y=mean(REML_rets$REML.Adjusted), col='darkred', pch=22,lwd=4)
stock_cor = cor(REML_rets$REML.Adjusted,SPY_rets$SPY.Adjusted)
summary(linTrReg)
#summary(polyReg)
cat(paste(tickers[1],"Correlation:", round(stock_cor,2)), '            ')
cat(paste(tickers[1],"R^2:", round(stock_cor^2,2), '                '))
cat(paste(tickers[1],'Beta Coefficient:'), round(coef(linTrReg)[2],2))
cat(paste(tickers[1],'Alpha:'), round(coef(linTrReg)[1] * length(REML_rets$REML.Adjusted) * 100,2)) #annualized
cat(paste(tickers[1],'Mean: '), round(mean(REML_rets$REML.Adjusted) * length(REML_rets$REML.Adjusted) * 100,2))
cat(paste(tickers[1],'Volatiltiy:'), round(sd(REML_rets$REML.Adjusted) * sqrt(length(REML_rets$REML.Adjusted)) * 100,2))
cat(paste(tickers[2],'Mean: '), round(mean(SPY_rets$SPY.Adjusted) * length(SPY_rets$SPY.Adjusted) * 100,2))
cat(paste(tickers[2],'Volatiltiy:'), round(sd(SPY_rets$SPY.Adjusted) * sqrt(length(SPY_rets$SPY.Adjusted)) * 100),2)
prob_error = (nrow(data[data$REML.Adjusted < 0 & data$SPY.Adjusted > 0,]) +
nrow(data[data$REML.Adjusted > 0 & data$SPY.Adjusted < 0,])
) / nrow(data)
cat('Probability of being off Diagonal (Historical): ', round(prob_error,4))
prob_topleft = (nrow(data[data$REML.Adjusted > 0 & data$SPY.Adjusted < 0,])) / nrow(data)
cat('Probability of being top left (Historical): ', round(prob_topleft,4))
prob_botright = (nrow(data[data$REML.Adjusted < 0 & data$SPY.Adjusted > 0,])) / nrow(data)
cat('Probability of being bottom right (Historical): ', round(prob_botright,4))
prob_topright = (nrow(data[data$REML.Adjusted > 0 & data$SPY.Adjusted > 0,])) / nrow(data)
cat('Probability of being top right (Historical): ', round(prob_topright,4))
prob_botleft = (nrow(data[data$REML.Adjusted < 0 & data$SPY.Adjusted < 0,])) / nrow(data)
cat('Probability of being bottom left (Historical): ', round(prob_botleft,4))
worst_case_BS <- function(c, S_0 = 100,  mu = 0.07, sigma=0.16, r = 0.02, t = 10/252){
Z = qnorm(1-c)
S_0 * exp((mu - 1/2 *  sigma^2 ) * t + sigma * sqrt(t) * Z)
}
worst_case_BS(.99, S_0=50)
worst_case_BS(.99, S_0=50)
worst_case_BS(.99, S_0=50)
worst_case_BS(.99, S_0=50)
worst_case_BS(.99, S_0=50)
Z
Z = qnorm(1-c)
Z = qnorm(1-.99)
Z
exp((mu - 1/2 *  sigma^2 ) * t + sigma * sqrt(t) * Z)
S_0=50
mu=.07
sigma=.16
r=0.02
t=10/252
c=.99
S_0 * exp((mu - 1/2 *  sigma^2 ) * t + sigma * sqrt(t) * Z)
exp((mu - 1/2 *  sigma^2 ) * t + sigma * sqrt(t) * Z)
sigma * sqrt(t) * Z
S_0 - worst_case_BS(.99, S_0=50)
W_0 / S_0 * worst_case_BS(c, S_0, mu, sigma, r, t)
worst_case_BS(c, S_0, mu, sigma, r, t)
S_0 * worst_case_BS(c, S_0, mu, sigma, r, t)
W_0=1000
W_0 / S_0 * worst_case_BS(c, S_0, mu, sigma, r, t)
VaR_portfolio <- function(E_0, W_0, c = 0.99, S_0 = 100,  mu = 0.07, sigma=0.16, r = 0.02, t = 10/252, long = T){
E_0 - W_0 / S_0 * worst_case_BS(c, S_0, mu, sigma, r, t) - (E_0 - W_0) * exp(r * t) # Value you have, Value in stock, Value in bonds
}
# solve for VaR = E_0
optimal_stock <- function(E_0, c = 0.99, S_0 = 100,  mu = 0.07, sigma=0.16, r = 0.02, t = 10/252, long = T){
to_solve <- function(W_0){
E_0 - VaR_portfolio(E_0, W_0, c, S_0,  mu, sigma, r, t)
}
uniroot(to_solve, c(0,10000))$root
}
# optimal portfolio position
optimal_stock(100, S_0= 50)
remove(list=ls())
?rnorm
qnorm(.025, .04, .18)
100000*qnorm(.025, .04, .18)
data(SP500, package="Ecdat")
install.packages("Ecdat")
library(Ecdat)
data(SP500, package="Ecdat")
head(SP500)
(1+n)
n = nrow(SP500)
SPreturn = SP500$r500[(n-999):n]
(1+n)
(1991.25 - 1981)
(1+n) * (1991.25 - 1981) / n
year = 1981 + (1+n) * (1991.25 - 1981) / n
alpha = 0.05
q = as.numeric(quantile(SP500, alpha))
year = 1981 + (1+n) * (1991.25 - 1981) / n # month april adjustment
alpha = 0.05
q = as.numeric(quantile(SP500, alpha))
q = as.numeric(quantile(SPreturn, alpha))
q
VaR_nonp = -20000 * q
VaR_nonp
(SPreturn < q)
sum(IEVaR)
IEVaR = (SPreturn < q)
sum(IEVaR)
ES_nonp = -20000 * sum(SPreturn * IEVaR) / sum(IEVaR)
ES_nonp
ES_nonp
IEVaR
sum(IEVaR)
sum(SPreturn * IEVaR) / sum(IEVaR)
SPreturn * IEVaR
SPreturn[IEVaR]
mean(SPreturn[IEVaR])
sum(SPreturn * IEVaR) / sum(IEVaR)
library(forecast)
setwd("D:/RedXCapital/crypto/Data")
library(quantmod)
getSymbols("^DJIA")
getSymbols("^DJI")
getSymbols("^DJI", from = "2000-01-01")
getSymbols("^DJI", from = "1990-01-01")
DJI$REt = DJI$DJI.Adjusted / lag(DJI$DJI.Adjusted) - 1
View(DJI)
DJI= na.omit(DJI)
model=auto.arima(DJI$REt, max.order = 20)
model
forecast(model,h=365)
forecasted_dji=forecast(model,h=365)
plot(forecasted_dji)
model=auto.arima(DJI$DJI.Adjusted, max.order = 20)
forecasted_dji=forecast(model,h=365)
plot(forecasted_dji)
tail(forecasted_dji$lower, 50)
tail(forecasted_dji$upper, 50)
tail(forecasted_dji$mean, 50)
summary(model)
acf(DJI$REt)
